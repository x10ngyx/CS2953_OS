uthread: switching between threads
- 实现用户态的线程（协程），与系统级的线程的区别在于：线程的切换需要显式地调用相关函数 (yield, schedule)
- 每个线程的需要保存的信息为：state, stack, context
- 在更换 sp, ra, s0 ~ s11 时需要精细到寄存器级别的操作，故直接编写汇编代码
using threads
- 用互斥锁保护哈希表，使其在多线程中安全
- 由于 bucket 之间独立，因此每个 bucket 用一个锁保护，可以提高并行度
barrier:
- 前 n-1 个到达的线程在发现条件不满足后进入睡眠
- 第 n 个到达的线程会唤醒所有的线程，并重置计数器，增加轮次
- 没有使用 while 循环来等待条件的满足，因此不会出现上一轮的线程被困住的情况。
  同时这也是正确的，因为在这个情景下不存在虚假唤醒的问题